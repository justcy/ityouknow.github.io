---
layout: post
title: "golang学习笔记"
tagline: ""
date: '2020-09-05 17:22:47 +0800'
category: golang
tags: golang golang学习笔记
keywords: golang,golang学习笔记
description: golang,golang学习笔记
---
> golang学习笔记
# 引言
golang语言学习笔记，需要时长回顾下
<!-- more -->

# 基础知识
## 基础语法
### map解析
map 声明,map声明的时候默认是nil,特别要注意一点，golang的map类型每次遍历出来的顺序可能不是一致的，要保证强一致性，需要使用 **有序遍历**
map底层数据结构
```go
type hmap struct {
    count        int  //元素个数
    flags        uint8   
    B            uint8 //扩容常量
    noverflow    uint16 //溢出 bucket 个数
    hash0        uint32 //hash 种子
    buckets      unsafe.Pointer //bucket 数组指针
    oldbuckets   unsafe.Pointer //扩容时旧的buckets 数组指针
    nevacuate    uintptr  //扩容搬迁进度
    extra        *mapextra //记录溢出相关
}
```
map常用的操作
```go
var m map[string]string
// 声明之后必须初始化，才能使用
m := make(map[string]string)
//新增元素
m["name"] = "张三"
//遍历
for k, v := range m { 
    fmt.Println(k, v)
}
//有序遍历
import "sort"
var keys []string
// 把key单独抽取出来，放在数组中
for k, _ := range m {
    keys = append(keys, k)
}
// 进行数组的排序
sort.Strings(keys)
// 遍历数组就是有序的了
for _, k := range keys {
    fmt.Println(k, m[k])
}
```
### 并发中的map
并发中的map并不是安全的，原因就是并发读写map，可通过以下实验证明：
```go
func main() {
	test := map[int]int {1:1}
	go func() {
		i := 0
		for i < 10000 {
			test[1]=1
			i++
		}
	}()
  go func() {
  i := 0
  for i &lt; 10000 {
  	test[1]=1
  	i++
  }
  }()
time.Sleep(2*time.Second)
fmt.Println(test)
}
//报错： fatal error: concurrent map writes
```
#### 优化方案1：加锁
加锁的方式简单，好理解，但是缺点是，锁的粒度是整个map，类似mysql的表级锁。
```go
func main() {
	test := map[int]int {1:1}
	var s sync.RWMutex
	go func() {
		i := 0
		for i < 10000 {
			s.Lock()
			test[1]=1
			s.Unlock()
			i++
		}
	}()
  go func() {
  i := 0
  for i &lt; 10000 {
  	s.Lock()
  	test[1]=2
  	s.Unlock()
  	i++
  }
  }()
time.Sleep(2*time.Second)
fmt.Println(test)
}
```
#### 优化方案2：官方方案
golang官方提供了sync.Map解决map并发读写，sync.Map里头已经实现了一套加锁的机制，因此能够让你更方便地使用map。
该做法优点：官方，通过空间换时间的方式，读写分离，缺点是：不适用于大量写的场景，这样会导致read map 读不到数据而进一步加锁读取，同时dirty map 也会一直晋升为read map，性能较差,所以该方案只适用于**大量读，少量写**的场景

```go
func main() {
	test := sync.Map{}
	test.Store(1, 1)
	go func() {
		i := 0
		for i < 10000 {
			test.Store(1, 1)
			i++
		}
	}()
	go func() {
		i := 0
		for i < 10000 {
			test.Store(1, 2)
			i++
		}
	}()
	time.Sleep(2*time.Second)
	fmt.Println(test)
}
```

#### 降低锁粒度

## go 内存模型

## sync模块

# 高级应用


# 扩展
关于该问题的扩展
---
参考：
- []()
- []()
