---
layout: post
title: "深入解析进程、线程、协程的区别"
tagline: ""
date: '2020-07-19 06:31:02 +0800'
category: linux
tags: linux 
keywords: linux,process,thread,coroutines,进程,线程,协程
description: linux,深入解析进程、线程、协程的区别
---
> 深入解析进程、线程、协程的区别

# 什么是进程

​		进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和
调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。
​		保存在计算硬盘上的程序，运行后，会在内存空间形成一个独立的内存体，它有自己的独立地址空间，有自己的堆，上级挂靠操作系统。操作系统以进程为单位，分配系统资源（CPU时间片，内存资源），进程是资源分配的最小单位。进程维护的是程序所包含的静态资源，如：地址空间、打开文件的句柄集、文件系统状态、信号处理handler等。

<img src="http://static.kanter.cn/uPic/2020/07/19_3709FEE7-26BF-4787-94FD-6E3743AC20A4.png" alt="进程结构图" style="zoom:50%;" />

## 进程的5种状态

1.初始化：初始化变量，申请内存空间等
2.就绪态：什么都准备好了等待系统分配CPU时间片
3.运行态:实际使用CPU
4.挂起态:等待除CPU外其他资源(主要是I/O)，主动放弃CPU占用。
5.停止态:进程生命周期结束，占用的资源被释放，回收。
<img src="http://static.kanter.cn/uPic/2020/07/19_E11A282F-6DFC-43C8-BA7F-95A0241F5F5E.png" alt="进程状态图" style="zoom:50%;" />

## 进程间的通信（IPC）

管道(Pipe)、命名管道(FIFO)、消息队列(Message Queue)、信号量(semaphore)、共享内存(Shared Memory)、套接字(Socket)

# 线程

线程，又被称为轻量级进程(lightweight process,LWP),是操作系统(CPU调度)执行的最小单位。线程由线程ID，当前指令指针(PC),寄存器集合和堆栈组成。它与同属一个进程的其他线程共享进程所拥有的所有资源。线程的出现主要是为了提高争夺CPU的概率。线程所维护的是程序运行相关的动态资源，如：运行栈、调度相关的控制信息、待处理的信号集等。

<img src="http://static.kanter.cn/uPic/2020/07/19_079F48E5-BD29-40EA-90AD-407A30682F28.png" alt="线程状态图" style="zoom:50%;" />

为什么说线程比进程轻量？

线程基本上不拥有系统资源，而进程需要占用系统资源。
## 多线程与多核
​	时间片轮转的调度方式说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。很多操作系统的书都说“同一时间点只有一个任务在执行”。那有人可能就要问双核处理器呢？难道两个核不是同时运行吗？
​	其实“同一时间点只有一个任务在执行”这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。

​	多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。

​	内核线程（Kernel Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。	

​	现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器\性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。

​	超线程技术就是利用特殊硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器能够使用线程级并行计算。进而兼容多线程操作系统和软件，减少CPU空闲时间，提高CPU使用效率。这种超线程技术由处理器硬件决定，同时需要操作系统支持才能在计算机中表现出来。

​	程序一般不会去使用内核线程，而是通过内核线程的高级接口-轻量级进程(light-weight-process,LWP),轻量级进程就是我们通常意义上说的线程，也被称为用户线程。由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。用户线程与内核线程的对应关系有三种模型：一对一，多对一，多对多。现在流行的操作系统，大多都采用多对多模型。

- 一对一：一个用户线程对应一个内核线程，但是一个内核线程不一定有对应的用户线程。优点：与内核线程一样，一个线程的阻塞不会影响其他线程。缺点：首先，内核线程数量限制了用户线程数量。其次，内核线程的调度，上下文切换开销大，导致用户线程执行效率下降。
- 多对一：多个用户线程对一一个内核线程，线程之间的切换由用户态的代码来进行，系统内核无法感知线程的实现方式。用户线程的创建、同步、销毁都在用户态中完成，无需内核介入。优点：上下文切换速度快，数量几乎无限制。缺点：首先，如果其中一个用户线程阻塞，那么所有线程都将无法执行，因为内核线程也阻塞了。其次，在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会明显增加，因为多个用户线程映射到了同一个处理器上了。
- 多对对：对多对模型结合一对一、多对一模型的优点，将多个用户线程映射到多个内核线程上。由线程库负责在可调度的实体上调度用户线程，这使得线程上下文切换非常快，优点：一个用户线程阻塞，不影响其他线程，因为还有别的内核线程来调度执行。用户线程数量没有上限，在多核处理器的操作系统中，多对多模型的线程能够得到一定的性能提升，但提升幅度不如一对一模型的高。 缺点：增加了复杂度(需要实现内核线程调度)，可能导致优先级倒置，以及用户态调度程序和内核调度程序之间没有广泛协调的次优调度。

## 线程死锁

代码逻辑控制有误，导致多个线程同时竞争唯一资源，线程陷入混乱，无序。

## 线程进程之间的区别

1. 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
2. 并发性：进程和进程之间可以并发，同一个进程的多个线程之间也可以并发。
3. 拥有资源：进程拥有资源的一个独立单位，线程不拥有系统的资源，但是可访问所属进程的资源。
4. 系统开销：在创建或撤销进程时，由于系统分配和回收资源，导致系统开销明显大于创建或撤销线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会影响其他进程，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉，就等于所有线程死掉。所以多进程的程序比多线程程序要健壮，但在进程切换时，耗费资源大，效率差。

# 协程
协程(coroutines),是一种基于线程之上，但又比线程更加轻量的存在，线程是程序自己来管理的轻量级线程，即用户空间线程，对内核来说是不可见的。一个线程可以拥有多个协程。协程可以轻松创建上万个而不会导致系统资源衰歇，而线程进程数量通常很难超过1w个，某个时刻只能有一个协程在运行，多个协程分享所属的线程分配到的计算资源。线程的产生是为了提高程序执行效率，充分利用CPU空闲时间执行其他任务。具体来说，当某个线程出现长时间的I/O阻塞时，自动让出CPU，让CPU能够执行下一个任务，从而避免上下文切换，提升效率。
## 协程特点
1. 线程的切换由操作系统负责，协程由用户自己进行调度(在同一个线程内，不会出现线程切换)，减少上下文切换，提升效率。
2. 线程默认stack大小1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。
3. 由于在同一个线程内，不存在同时写变量冲突，在协程中控制共享资源不需要加锁，只需要判断状态，也就是说，可以避免竞争关系而使用锁。
4. 适用于被阻塞，且需要大量并发的场景。但不适用于大量计算的多线程，遇到这种情况，最好用线程去解决。


## go协程
go协程，叫goroutine。在进程中创建，比线程更小，十几个goroutine可能体现在底层就五六个线程，go语言内部实现了goroutine之间的内存共享(golang原生支持协程)。执行goroutine只需要极少的栈内存(大概4-5kb)，正是因为这样，goroutine可同时运行成千上万个并发任务。

## 协程原理
正在执行的线程内部，当出现I/O阻塞的时候，由协程调度器进行调度(Fiber)，通过将数据流立刻yield掉(主动让出CPU)，并且记录当前栈上的数据，阻塞完成后再通过线程恢复栈，并把阻塞的结果放到线程上去跑，这个流程可以称为：coroutine，这样看上去好像跟写同步代码没任何差别。在golang里，go关键词其实就是负责开启一个协程调度器(Fiber),让Func逻辑跑在上面。
由于协程的暂停完全是由程序控制，发生在用户态上，而线程的阻塞状态是由操作系统内核来进行切换的，发生在内核态上。因此，协程的开销远小于线程的开销。

## 协程与线程比较

| 比较项 | 线程 | 协程 |
| :----: | :--: | :--: |
| 占用资源 | 初始1M,固定不可变 | 初始2k左右，可随需要增大 |
| 调度所属 |由系统内核完成 | 由用户完成 |
| 切换开销 | 涉及模式切换（从用户态转到内核态）、16个寄存器、PC、SP……等寄存器的刷新 | 只有三个寄存器 PC / SP / DX |
| 性能问题 |资源占用太高，频繁创建销毁带来严重的性能问题|资源占用小不会带来严重性能问题|
| 数据同步 | 需要用锁确保数据一致性和可见性 | 不需要多线程锁机制，不存在写变量冲突，只需要判断状态，也就是说，可以避免竞争关系而使用锁 |



# 扩展

## CPU调度算法

## 先到先服务(FCFS)

先来先服务，就是 FCFS,First Come,First Serviced,。线程就绪后，进入到FIFO队列中，CPU会挨个服务于FIFO中的线程，这种方式，后面到的线程不能抢占前面正在服务的线程。这种算法优点是实现简单。缺点：当CPU进程区间变化很大的时候，平均等待时间就会变化很大。

周转时间=任务结束的时间-任务到达的时间

假设：

| 进程名 | 到达时间 | 服务时间 |
| :----: | :----: | :------: |
|   A    |    0     |5 |
|   B    |    1     |    60    |
|   C    |    2     |   100    |
|   D    |    3     |    10    |

若按照FCFS 则调度顺序为A->B->C->D
四个任务的平均周转时间为=((5-0)+(65-1)+(165-2)+(175-3))/4 = 101

## 最短作业优先算法(SJF)

最短作业优先，Short job first。顾名思义，就是线程所需要的最短服务时间的先执行。如果所需时间相同，按照FCFS来调度。SJF可以是抢占的，也可以是不抢占的。它的平均等待时间优于FCFS。

假设：

| 进程名 | 到达时间 | 服务时间 |
| :----: | :------: | :------: |
|   A    |    0     |    5     |
|   B    |    1     |    60    |
|   C    |    2     |   100    |
|   D    |    3     |    10    |

若按照FCFS 则调度顺序为A->D->B->C
四个任务的平均周转时间为=((5-0)+(15-3)+(75-1)+(175-2))/4 = 66

很明显，在以短任务为主的系统中，SJF的调度算法平均周转时间比FCFS的平均周转时间要低。
## 时间片轮转算法
时间片轮转，Round Robin。该算法首先设置一个时间片，如：10，然后不停的在A、B、C、D四个进程之间切换，每个进程执行一个单位时间片，时间到了，就切换到下一个。直到全部执行完。此算法时间片设置很关键，过大，则相应时间太长，过小，那系统很多时间将浪费在进程切换，导致吞吐量小。最佳的时间片选择为10-100ms,切换时间为0.1-1ms。
SJF关注平均周转时间，RR算法关注系统相应时间。
## 优先级调度
优先级调度，Priority Scheduling Algorithm。进入就绪后，给每个进程一个优先级，优先级越高的越紧急，应该先执行。一般系统进程高于用户进程，前台进程高于后台进程。这种算法实现简单，但是缺乏公平性，很可能导致优先级低的进程被饿死。另外，若一个低优先级进程持有一个高优先级进程所需要的资源，则会造成优先级反转，高优先级等待低优先级运行后再运行。
## 虚拟轮转算法
虚拟轮转算法，Virtual RR。该算法基于RR算法改进，能够解决CPU调度中对于进程大小相似的进程集不利性。该算法会设置一个辅助队列，每个进程执行完一个时间片后，进入辅助队列，CPU调度之前先检查该队列，若队列不为空，则优先执行队列中的进程，直到辅助队列为空，再调度执行就绪队列。
## 各个算法的对比

| 调度算法 | 占用CPU方式 | 吞吐量 | 响应时间 | 开销 | 对进程的影响 | 饥饿问题 |
| :----: | :------: | :------: | :------: | :------: | :------: | :------: |
|   FCFS    |   非抢占     |   不强调     |  可能很慢，特别是进程执行时间差别很大的情况下     |   最小     |   对短进程不利；对I/O型进程不利     |   无     |
| Round Robin |   抢占(时间片用完时)   |   若时间片小，吞吐量会很低   | 为短进程提供好的响应时间 |   最小     |   公平   |   无     |
|   SJF   |   非抢占  |   高     | 为短进程提供好的响应时间 |   可能较大   |   对长进程不利    |   可能   |
|   SRTN   |   抢占(到达时)   |   高    | 提供好的响应时间 |   可能较大 | 对长进程不利 |   可能   |
|   HRRN   |   非抢占  |   高    | 提供好的响应时间 |   可能较大 |   很好的平滑   |   无     |
|   Feedback   |   抢占(时间片用完时)   |   不强调     |  不强调  |   可能较大 |   对I/O型进程有利    |   可能   |
## 进程/线程之间的亲缘性

亲缘性：是指在多核系统情况下，进程/线程只在某个CPU上运行

如：

```
BOOL WINAPI SetProcessAffinityMask(
    _In_ HANDLE hProcess,
    _In_ DWORD_PTR dwProcessAffinityMask
);
/*
dwProcessAffinityMask 如果是 0 , 代表当前进程只在cpu0 上工作;
如果是 0x03 , 转为2进制是 00000011 . 代表只在 cpu0 或 cpu1上工作;
*/
```

这样做的好处：防止进程/线程在CPU的核上频繁切换，从而避免因为切换带来的CPU的L1/L2 cache失效，cache失效会降低程序性能。
## 操作系统
操作系统的设计，因此可以归结为三点：
1. 以多进程形式，允许多个任务同时运行；
2. 以多线程形式，允许单个任务分成不同的部分运行；
3. 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。

---
参考：
- [进程、线程和协程之间的区别和联系](https://blog.csdn.net/daaikuaichuan/article/details/82951084)

- [一文读懂什么是进程、线程、协程](https://www.cnblogs.com/Survivalist/p/11527949.html)

- [程序、进程、线程、协程之间的关系](https://blog.csdn.net/junaozun/article/details/90268569)

- [进程、线程和协程的理解](https://www.cnblogs.com/guolei2570/p/8810536.html)

  

